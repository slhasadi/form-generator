{"version":3,"file":"validator-ajv8.cjs.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv, { Options } from \"ajv8\";\nimport addFormats, { FormatsPluginOptions } from \"ajv-formats\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport {\n  ADDITIONAL_PROPERTY_FLAG,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from \"@rjsf/utils\";\n\nexport const AJV_CONFIG: Options = {\n  allErrors: true,\n  multipleOfPrecision: 8,\n  strict: false,\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {},\n  ajvFormatOptions?: FormatsPluginOptions | false,\n  AjvClass: typeof Ajv = Ajv\n) {\n  const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n  if (ajvFormatOptions) {\n    addFormats(ajv, ajvFormatOptions);\n  } else if (ajvFormatOptions !== false) {\n    addFormats(ajv);\n  }\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\n  ajv.addKeyword(RJSF_ADDITONAL_PROPERTIES_FLAG);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import Ajv, { ErrorObject, ValidateFunction } from \"ajv8\";\nimport toPath from \"lodash/toPath\";\nimport isObject from \"lodash/isObject\";\nimport clone from \"lodash/clone\";\nimport {\n  CustomValidator,\n  ERRORS_KEY,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  getDefaultFormState,\n  mergeValidationData,\n  REF_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  ValidationData,\n  ValidatorType,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType, Localizer } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n> implements ValidatorType<T>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const {\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides,\n      ajvFormatOptions,\n      AjvClass,\n    } = options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides,\n      ajvFormatOptions,\n      AjvClass\n    );\n    this.localizer = localizer;\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: ErrorObject[] = []\n  ): RJSFValidationError[] {\n    return errors.map((e: ErrorObject) => {\n      const { instancePath, keyword, message, params, schemaPath } = e;\n      const property = instancePath.replace(/\\//g, \".\");\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(\n    schema: RJSFSchema,\n    formData?: T\n  ): { errors?: Result[]; validationError?: Error } {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema[\"$id\"]) {\n      compiledValidator = this.ajv.getSchema(schema[\"$id\"]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === \"function\") {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    const { validationError: invalidSchemaError } = rawErrors;\n    let errors = this.transformRJSFValidationErrors(rawErrors.errors);\n\n    if (invalidSchemaError) {\n      errors = [...errors, { stack: invalidSchemaError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (invalidSchemaError) {\n      errorSchema = {\n        ...errorSchema,\n        $schema: {\n          __errors: [invalidSchemaError!.message],\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    // Include form data with undefined values, which is required for custom validation.\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      schema,\n      true\n    ) as T;\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: S) {\n    for (const key in node) {\n      const realObj: GenericObjectType = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: S[]): S[] {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]) as S;\n    }\n    return node;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T, rootSchema: S) {\n    const rootSchemaId = rootSchema[\"$id\"] ?? ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      if (this.ajv.getSchema(rootSchemaId) === undefined) {\n        this.ajv.addSchema(rootSchema, rootSchemaId);\n      }\n      const schemaWithIdRefPrefix = this.withIdRefPrefix(schema) as S;\n      let compiledValidator: ValidateFunction | undefined;\n      if (schemaWithIdRefPrefix[\"$id\"]) {\n        compiledValidator = this.ajv.getSchema(schemaWithIdRefPrefix[\"$id\"]);\n      }\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn(\"Error encountered compiling schema:\", e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: S | S[]): S | S[] {\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    if (isObject(schemaNode)) {\n      return this.withIdRefPrefixObject(clone<S>(schemaNode));\n    }\n    return schemaNode;\n  }\n}\n","import { RJSFSchema, StrictRJSFSchema, ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType, Localizer } from \"./types\";\nimport AJV8Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  options: CustomValidatorOptionsType = {},\n  localizer?: Localizer\n): ValidatorType<T, S> {\n  return new AJV8Validator<T, S>(options, localizer);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","allErrors","multipleOfPrecision","strict","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","AJV8Validator","constructor","options","localizer","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","Ajv","addFormats","addFormat","addKeyword","ADDITIONAL_PROPERTY_FLAG","RJSF_ADDITONAL_PROPERTIES_FLAG","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","value","formObject","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","instancePath","keyword","params","schemaPath","replace","name","trim","rawValidation","schema","compilationError","compiledValidator","getSchema","undefined","compile","err","validationError","validateFormData","customValidate","transformErrors","rawErrors","invalidSchemaError","$schema","newFormData","getDefaultFormState","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","rootSchemaId","addSchema","schemaWithIdRefPrefix","console","warn","removeSchema","schemaNode","clone","customizeValidator","index"],"mappings":"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"}