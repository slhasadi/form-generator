'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toPath = require('lodash/toPath');
var isObject = require('lodash/isObject');
var clone = require('lodash/clone');
var utils = require('@rjsf/utils');
var Ajv = require('ajv8');
var addFormats = require('ajv-formats');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var toPath__default = /*#__PURE__*/_interopDefaultLegacy(toPath);
var isObject__default = /*#__PURE__*/_interopDefaultLegacy(isObject);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var addFormats__default = /*#__PURE__*/_interopDefaultLegacy(addFormats);

const AJV_CONFIG = {
  allErrors: true,
  multipleOfPrecision: 8,
  strict: false
};
const COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/;
const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.
 * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the
 * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If
 * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing
 * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By
 * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`
 * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of
 * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.
 *
 * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access
 * @param [customFormats] - The set of additional custom formats that the validator will support
 * @param [ajvOptionsOverrides={}] - The set of validator config override options
 * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it
 * @param [AjvClass] - The `Ajv` class to use when creating the validator instance
 */
function createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass) {
  if (ajvOptionsOverrides === void 0) {
    ajvOptionsOverrides = {};
  }
  if (AjvClass === void 0) {
    AjvClass = Ajv__default["default"];
  }
  const ajv = new AjvClass({
    ...AJV_CONFIG,
    ...ajvOptionsOverrides
  });
  if (ajvFormatOptions) {
    addFormats__default["default"](ajv, ajvFormatOptions);
  } else if (ajvFormatOptions !== false) {
    addFormats__default["default"](ajv);
  }
  // add custom formats
  ajv.addFormat("data-url", DATA_URL_FORMAT_REGEX);
  ajv.addFormat("color", COLOR_FORMAT_REGEX);
  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.
  ajv.addKeyword(utils.ADDITIONAL_PROPERTY_FLAG);
  ajv.addKeyword(utils.RJSF_ADDITONAL_PROPERTIES_FLAG);
  // add more schemas to validate against
  if (Array.isArray(additionalMetaSchemas)) {
    ajv.addMetaSchema(additionalMetaSchemas);
  }
  // add more custom formats to validate against
  if (isObject__default["default"](customFormats)) {
    Object.keys(customFormats).forEach(formatName => {
      ajv.addFormat(formatName, customFormats[formatName]);
    });
  }
  return ajv;
}

const ROOT_SCHEMA_PREFIX = "__rjsf_rootSchema";
/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.
 */
class AJV8Validator {
  /** The AJV instance to use for all validations
   *
   * @private
   */

  /** The Localizer function to use for localizing Ajv errors
   *
   * @private
   */

  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  constructor(options, localizer) {
    this.ajv = void 0;
    this.localizer = void 0;
    const {
      additionalMetaSchemas,
      customFormats,
      ajvOptionsOverrides,
      ajvFormatOptions,
      AjvClass
    } = options;
    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);
    this.localizer = localizer;
  }
  /** Transforms a ajv validation errors list:
   * [
   *   {property: '.level1.level2[2].level3', message: 'err a'},
   *   {property: '.level1.level2[2].level3', message: 'err b'},
   *   {property: '.level1.level2[4].level3', message: 'err b'},
   * ]
   * Into an error tree:
   * {
   *   level1: {
   *     level2: {
   *       2: {level3: {errors: ['err a', 'err b']}},
   *       4: {level3: {errors: ['err b']}},
   *     }
   *   }
   * };
   *
   * @param errors - The list of RJSFValidationError objects
   * @private
   */
  toErrorSchema(errors) {
    if (!errors.length) {
      return {};
    }
    return errors.reduce((errorSchema, error) => {
      const {
        property,
        message
      } = error;
      const path = toPath__default["default"](property);
      let parent = errorSchema;
      // If the property is at the root (.level1) then toPath creates
      // an empty array element at the first index. Remove it.
      if (path.length > 0 && path[0] === "") {
        path.splice(0, 1);
      }
      for (const segment of path.slice(0)) {
        if (!(segment in parent)) {
          parent[segment] = {};
        }
        parent = parent[segment];
      }
      if (Array.isArray(parent.__errors)) {
        // We store the list of errors for this node in a property named __errors
        // to avoid name collision with a possible sub schema field named
        // 'errors' (see `validate.createErrorHandler`).
        parent.__errors = parent.__errors.concat(message);
      } else {
        if (message) {
          parent.__errors = [message];
        }
      }
      return errorSchema;
    }, {});
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   */
  toErrorList(errorSchema, fieldPath) {
    if (fieldPath === void 0) {
      fieldPath = [];
    }
    if (!errorSchema) {
      return [];
    }
    let errorList = [];
    if (utils.ERRORS_KEY in errorSchema) {
      errorList = errorList.concat(errorSchema.__errors.map(message => {
        const property = `.${fieldPath.join(".")}`;
        return {
          property,
          message,
          stack: `${property} ${message}`
        };
      }));
    }
    return Object.keys(errorSchema).reduce((acc, key) => {
      if (key !== utils.ERRORS_KEY) {
        acc = acc.concat(this.toErrorList(errorSchema[key], [...fieldPath, key]));
      }
      return acc;
    }, errorList);
  }
  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it
   *
   * @param formData - The form data around which the error handler is created
   * @private
   */
  createErrorHandler(formData) {
    const handler = {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // 'errors' (see `utils.toErrorSchema`).
      __errors: [],
      addError(message) {
        this.__errors.push(message);
      }
    };
    if (Array.isArray(formData)) {
      return formData.reduce((acc, value, key) => {
        return {
          ...acc,
          [key]: this.createErrorHandler(value)
        };
      }, handler);
    }
    if (isObject__default["default"](formData)) {
      const formObject = formData;
      return Object.keys(formObject).reduce((acc, key) => {
        return {
          ...acc,
          [key]: this.createErrorHandler(formObject[key])
        };
      }, handler);
    }
    return handler;
  }
  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it
   *
   * @param errorHandler - The `FormValidation` error handling structure
   * @private
   */
  unwrapErrorHandler(errorHandler) {
    return Object.keys(errorHandler).reduce((acc, key) => {
      if (key === "addError") {
        return acc;
      } else if (key === utils.ERRORS_KEY) {
        return {
          ...acc,
          [key]: errorHandler[key]
        };
      }
      return {
        ...acc,
        [key]: this.unwrapErrorHandler(errorHandler[key])
      };
    }, {});
  }
  /** Transforming the error output from ajv to format used by @rjsf/utils.
   * At some point, components should be updated to support ajv.
   *
   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`
   * @private
   */
  transformRJSFValidationErrors(errors) {
    if (errors === void 0) {
      errors = [];
    }
    return errors.map(e => {
      const {
        instancePath,
        keyword,
        message,
        params,
        schemaPath
      } = e;
      const property = instancePath.replace(/\//g, ".");
      // put data in expected format
      return {
        name: keyword,
        property,
        message,
        params,
        stack: `${property} ${message}`.trim(),
        schemaPath
      };
    });
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */
  rawValidation(schema, formData) {
    let compilationError = undefined;
    let compiledValidator;
    if (schema["$id"]) {
      compiledValidator = this.ajv.getSchema(schema["$id"]);
    }
    try {
      if (compiledValidator === undefined) {
        compiledValidator = this.ajv.compile(schema);
      }
      compiledValidator(formData);
    } catch (err) {
      compilationError = err;
    }
    let errors;
    if (compiledValidator) {
      if (typeof this.localizer === "function") {
        this.localizer(compiledValidator.errors);
      }
      errors = compiledValidator.errors || undefined;
      // Clear errors to prevent persistent errors, see #1104
      compiledValidator.errors = null;
    }
    return {
      errors: errors,
      validationError: compilationError
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   */
  validateFormData(formData, schema, customValidate, transformErrors) {
    const rawErrors = this.rawValidation(schema, formData);
    const {
      validationError: invalidSchemaError
    } = rawErrors;
    let errors = this.transformRJSFValidationErrors(rawErrors.errors);
    if (invalidSchemaError) {
      errors = [...errors, {
        stack: invalidSchemaError.message
      }];
    }
    if (typeof transformErrors === "function") {
      errors = transformErrors(errors);
    }
    let errorSchema = this.toErrorSchema(errors);
    if (invalidSchemaError) {
      errorSchema = {
        ...errorSchema,
        $schema: {
          __errors: [invalidSchemaError.message]
        }
      };
    }
    if (typeof customValidate !== "function") {
      return {
        errors,
        errorSchema
      };
    }
    // Include form data with undefined values, which is required for custom validation.
    const newFormData = utils.getDefaultFormState(this, schema, formData, schema, true);
    const errorHandler = customValidate(newFormData, this.createErrorHandler(newFormData));
    const userErrorSchema = this.unwrapErrorHandler(errorHandler);
    return utils.mergeValidationData(this, {
      errors,
      errorSchema
    }, userErrorSchema);
  }
  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling
   * `withIdRefPrefix` for any other elements.
   *
   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @private
   */
  withIdRefPrefixObject(node) {
    for (const key in node) {
      const realObj = node;
      const value = realObj[key];
      if (key === utils.REF_KEY && typeof value === "string" && value.startsWith("#")) {
        realObj[key] = ROOT_SCHEMA_PREFIX + value;
      } else {
        realObj[key] = this.withIdRefPrefix(value);
      }
    }
    return node;
  }
  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling
   * `withIdRefPrefix` for any other elements.
   *
   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @private
   */
  withIdRefPrefixArray(node) {
    for (let i = 0; i < node.length; i++) {
      node[i] = this.withIdRefPrefix(node[i]);
    }
    return node;
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  isValid(schema, formData, rootSchema) {
    const rootSchemaId = rootSchema["$id"] ?? ROOT_SCHEMA_PREFIX;
    try {
      // add the rootSchema ROOT_SCHEMA_PREFIX as id.
      // then rewrite the schema ref's to point to the rootSchema
      // this accounts for the case where schema have references to models
      // that lives in the rootSchema but not in the schema in question.
      if (this.ajv.getSchema(rootSchemaId) === undefined) {
        this.ajv.addSchema(rootSchema, rootSchemaId);
      }
      const schemaWithIdRefPrefix = this.withIdRefPrefix(schema);
      let compiledValidator;
      if (schemaWithIdRefPrefix["$id"]) {
        compiledValidator = this.ajv.getSchema(schemaWithIdRefPrefix["$id"]);
      }
      if (compiledValidator === undefined) {
        compiledValidator = this.ajv.compile(schemaWithIdRefPrefix);
      }
      const result = compiledValidator(formData);
      return result;
    } catch (e) {
      console.warn("Error encountered compiling schema:", e);
      return false;
    } finally {
      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.
      // make sure we remove the rootSchema from the global ajv instance
      this.ajv.removeSchema(rootSchemaId);
    }
  }
  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`
   * This is used in isValid to make references to the rootSchema
   *
   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @protected
   */
  withIdRefPrefix(schemaNode) {
    if (Array.isArray(schemaNode)) {
      return this.withIdRefPrefixArray([...schemaNode]);
    }
    if (isObject__default["default"](schemaNode)) {
      return this.withIdRefPrefixObject(clone__default["default"](schemaNode));
    }
    return schemaNode;
  }
}

/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if
 * provided.
 *
 * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 */
function customizeValidator(options, localizer) {
  if (options === void 0) {
    options = {};
  }
  return new AJV8Validator(options, localizer);
}

var index = /*#__PURE__*/customizeValidator();

exports.customizeValidator = customizeValidator;
exports["default"] = index;
//# sourceMappingURL=validator-ajv8.cjs.development.js.map
